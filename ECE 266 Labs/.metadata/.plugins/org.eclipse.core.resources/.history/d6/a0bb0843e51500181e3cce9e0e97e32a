;****************************************************************
; homework4.asm: Assembly starter code for homework 4 assignment.
;
; Created by Zhao Zhang for ECE 266 spring 2018
;****************************************************************

; include the C declarations in homework3.h in this assembly program
                .cdecls "homework4.h"

                .text

;****************************************************************
; Problem 2
; void add4int64(int64_t a, int 64_t b, int 64_t c, int64_t d)
;   Return a+b+c+d
;****************************************************************
                .global add4Int64
add4Int64       .asmfunc
				LDR r0, =0xFFFFFFFF
				LDR r1, =0x00000002
				LDR r2, =0x00000004
				LDR r3, =0x00000006
				LDR r4, =0x00000008
				LDR r5, =0x0000000A
				LDR r6, =0x0000000C
				LDR r7, =0x0000000E
				ADDS r0, r0, r2
				ADDS r2, r0, r4
				ADDS r4, r2, r6
				ADC r1, r1, r3
				ADC r3, r1, r5
				ADC r5, r3, r7
                BX    lr
                .endasmfunc

;****************************************************************
; Problem 3
; unsigned gcd(unsigned a, unsigned b)
;   Return the GCD of a and b
;****************************************************************
                .global gcd
gcd             .asmfunc

                BX    lr
                .endasmfunc

;****************************************************************
; Problem 4
; int64_t sub64(int64_t a, int64_t b)
;   64-bit subtracut
;****************************************************************
                .global sub64
sub64		.asmfunc
				SUBS r0, r2
				SBC r1, r3
				BX    lr
                .endasmfunc

;****************************************************************
; Problem 5
; uint64_t umult64(uint32_t a, uint32_t b)
;   32-bit unsigned multiply with 64-bit result
;****************************************************************
                .global umult64
umult64         .asmfunc
				UMULL r0, r1, r0, r1
				BX    lr
                .endasmfunc

;****************************************************************
; Problem 6
; uint32_t reverseByte(uint32_t n)
;   Reverse byte ordering. Must use REV instruction.
;****************************************************************
                .global reverseByte
reverseByte     .asmfunc
				REV r0, r0
				BX    lr
                .endasmfunc


;****************************************************************
; Problem 7
; int32_t signExt8to32(int8_t n)
;   sign-extend from 8-bit to 32-bit. Must use a sign-extension 
;   instrunction.
;****************************************************************
                .global signExt8to32
signExt8to32    .asmfunc
				SXTB r0, r0
				BX    lr
                .endasmfunc


;****************************************************************
; Problem 8
; uint32_t rotateRight8(uint32_t n)
;   Rotate right by 8 bits. Must use MOV instruction with built-in
;   rotate or ROR instruction. The latter is a pseudo instruction
;   for the former.
;****************************************************************
                .global rotateRight8
rotateRight8    .asmfunc
				MOV r0, r0, ROR #8
				BX    lr
                .endasmfunc

;****************************************************************
; int32_t multiply17(int32_t x)
;   Multiply by 17, must NOT use any multiply instruction. Hint:
;   Use an ADD instruction with built-in shift.
;****************************************************************
                .global multiply17
multiply17      .asmfunc
				ADD r0, r0, LSL #4
				BX    lr
                .endasmfunc

; Do NOT forget the function return in each of the above functions.
; The following is a catch-up function return.  With your solution
; code, the program execution should not reach here.
                BX    lr

